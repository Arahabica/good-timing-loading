<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="ローディング表示のシミュレーションができるウェブアプリケーションです。" />
  <meta property="og:title" content="Loading Simulation" />
  <meta property="og:type" content="website"/>
  <meta property="og:url" content="https://d-sharp.com" />
  <meta property="og:image" content="https://loading.rsasage.com/good_loading_icon.png" />
  <meta property="og:site_name" content="Loading Simulation" />
  <meta property="og:description" content="ローディング表示のシミュレーションができるウェブアプリケーションです。" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:description" content="ローディング表示のシミュレーションができるウェブアプリケーションです。" />
  <meta name="twitter:title" content="Loading Simulation" />
  <meta name="twitter:site" content="@Arahabica1" />
  <meta name="twitter:image" content="https://loading.rsasage.com/good_loading_icon.png" />
  <meta name="twitter:creator" content="@Arahabica1" />
  <link rel="stylesheet" href="./random.css" />
  <title>Loading Simulation (Random)</title>
</head>
<body>
  <section class="landing">
    <h1>Loading Simulation<br/>(Random)</h1>
    <p>ちらつき対策をしているローディングです。</p>
    <p>処理時間は50〜1200msの間でランダムに変わります。</p>
    <button class="next" style="margin-top: 36px;">次へ</button>
    <p>「次へ」を押すとローディングが始まります</p>
    <div class="links">
      <h2>Demos</h2>
      <ul>
        <li><a href="./">Loading Simulation</a></li>
        <li>Loading Simulation (Random)</li>
        <li><a href="./multi.html">Loading Simulation (Multi)</a></li>
      </ul>
    </div>
  </section>
  <svg class="loading hidden" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
      <circle fill="none" stroke-width="4" cx="20" cy="20" r="18"></circle>
  </svg>
  <section class="content hidden">
    <div class="main">Hello</div>
    <div>loaded: <span class="loading-time"></span> ms</div>
    <button class="reset">リセット</button>
  </section>
  <section class="error-content hidden">
    <div class="error-message">Something went wrong!</div>
    <button class="reset">リセット</button>
  </section>
</body>
<script>
  const waitLoadingAnimation = async (callback, opts) => {
    const delay = opts?.delay ?? 350; // ドーハティ閾値(400ms) - バッファ(50ms)
    const minDuration = opts?.minDuration ?? 600; // 最小表示時間
    // Delayを超えた場合に強制される合計の最小待ち時間
    const requiredWaitTime = delay + minDuration; // 950ms

    const startTime = Date.now();

    // 1. コールバック関数を即座に実行
    const callbackPromise = callback();

    try {
      // 2. 処理の完了を待機
      const result = await callbackPromise;
      const finishedTime = Date.now();
      const actualTime = finishedTime - startTime;

      // 3. Min Durationの適用判定
      if (actualTime < delay) {
        // delay以内に完了した場合は即座に結果を返す (ノイズレス)
        return result;
      }
      // 処理時間がDelayを超えた場合、ローディングが表示されたとみなし、
      // Min Durationのルールを適用する。
      const remainingTime = Math.max(requiredWaitTime - actualTime, 0);

      // 4. 不足している時間分だけ人工的に待機
      if (remainingTime > 0) {
        console.log("Waiting for min duration:", remainingTime);
        // Promiseが解決したにも関わらず、ローディング表示を維持する
        await new Promise((resolve) => {
          setTimeout(resolve, remainingTime);
        });
      }
      return result;
    } catch (error) {
      // エラー時も同様にMin Durationのルールを適用し、チラつきを防ぐ
      const errorTime = Date.now();
      const actualErrorTime = errorTime - startTime;

      if (actualErrorTime > delay) {
        const remainingTime = Math.max(requiredWaitTime - actualErrorTime, 0);
        if (remainingTime > 0) {
          console.log("Waiting for min duration:", remainingTime);
          await new Promise((resolve) => {
            setTimeout(resolve, remainingTime);
          });
        }
      }
      // 待機完了後にエラーをスロー
      throw error;
    }
  };

  const landing = document.querySelector(".landing");
  const loading = document.querySelector(".loading");
  const content = document.querySelector(".content");
  const errorContent = document.querySelector(".error-content");
  const nextButton = document.querySelector(".next");
  const resetButton = document.querySelectorAll(".reset");

  function setHidden(element, hidden) {
    if (hidden) {
        element.classList.add("hidden");
    } else {
        element.classList.remove("hidden");
    }
  }
  function setState(state) {
    setHidden(landing, state !== "none");
    setHidden(loading, state !== "loading");
    setHidden(content, state !== "loaded");
    setHidden(errorContent, state !== "error");
  }
  async function doSomething() {
    // 50〜1200msの間でランダムに待機
    const duration = 50 + Math.floor(21 * Math.random()) * 50;
    return new Promise((resolve, reject) => {
        setTimeout(() => {
          if (Math.random() < 0.2) {
              // 20%の確率でエラーをスロー
              reject(new Error("Something went wrong!"));
          }
          resolve(duration);
        }, duration);
    });
  }

  nextButton.addEventListener("click", async () => {
    setState("loading");
    try {
      const duration = await waitLoadingAnimation(() => doSomething());
      content.querySelector(".loading-time").textContent = duration.toFixed(0);
      setState("loaded");
    } catch (error) {
        setState("error");
        return;
    }
  });
  resetButton.forEach(button => {
    button.addEventListener("click", () => {
        setState("none");
    });
  });
</script>
</html>