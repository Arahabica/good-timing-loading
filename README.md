# 概要

このリポジトリは[この記事](https://rsasage.com)の解説用のものになります。


## セットアップ
`Node.js`、`npm` がインストールされている環境で、下記コマンドを実行してください。

```
npm install
```

## 実行

下記コマンドで実行できます。

```sh
npm start
```

---

## はじめに

ローディング表示にこだわるフロントエンジニアは少ないと思いますが、ここを改善するとUIはぐっと洗練されます。


[ちらつきの発生しているローディングのgif画像]

例えば、上記のローディング表示ですが、100msだけ表示されており、ユーザーにとってちらつきとして受け止められてしまいます。
このような例だとローディングを表示しない方が良いでしょう。
この記事では洗練されたローディング表示について深掘っていきます。

## 表示の遅延 (Delay)

そもそもローディング表示が必要なのはシステムがちゃんと処理をしているのをユーザーに知らせるためです。
システムが一定時間以上反応がないとユーザーはストレスを感じ始めます。
この一定時間というのはちゃんと研究されていて、400msが閾値とされています（ドハティの法則）。

逆にいうと400ms未満であれば無反応でも許容されるので、400ms以内に終わる処理ではローディングは表示しないのが良いUIと言えるでしょう。

## 最低表示時間 (Min Duration）

400ms経ってからローディングを始めても、500msで処理が終わったら、ローデイングを表示する時間は100msになってしまい、結局ちらつきが発生してしまいます。

このような場合には500ms〜600msほどの最低表示時間を設けるようにしましょう。
ユーザーに表示する準備が整っているのに、あえて表示を遅らせるのは、パフォーマンス命のエンジニアにとっては受け入れ難いかもしれません。
ただ、UIの観点に立つと、ちらつきが発生するよりは少し待たせる方がユーザー体験は向上します。

ユーザビリティ研究のヤコブ・ニールセンによるとユーザーは1000msを超えると思考が途切れ始めるとのことです。表示を遅らせてもこの1秒の閾値を超えていなければ、集中力をとぎらせることはない範囲に収まっているので安心して良いかと思います。

どうしてもスピードを求めたい人は400ms以内を目指すべきでしょう。

## おすすめのローディング表示時間

* delay: 350ms
  * ドハティの法則では400msですが、少しバッファをもうけて350msにします。
* minDulation: 600ms
  * delayと足して1000msを超えないように600msにしました。

まとめると下記のようになります。




| 処理時間 | ローディングの最終的な挙動 |
| ---- | ---- |
| ~ 350ms | ローディングを表示しない（Delayが終了する前に処理完了） |
| 350ms 〜 950ms | 350ms経ってからローディングが表示され、処理が950msになるまで表示が強制維持される (Min Durationが適用) |
| 950ms 〜 | 350ms経ってからローディングが表示され、処理が終わるまで表示される |



下記が表示結果です。


[それぞれのローディングのgif画像]


## 実装

(これから)
(TypeScriptの実装例)

```js
async function doSomething() {
   // 0〜1200msの間でランダムに待機
   const duration = Math.floor(24 * Math.random()) * 50;
   return new Promise((resolve, reject) => {
      setTimeout(() => {
         if (Math.random() < 0.2) {
            // 20%の確率でエラーをスロー
            reject(new Error("Something went wrong!"));
         }
         resolve(duration);
      }, duration);
   });
}

nextButton.addEventListener("click", async () => {
   changeState("loading");
   try {
     await waitLoadingAnimation(() => doSomething());
     content.querySelector(".loading-time").textContent = duration.toFixed(0);
     changeState("loaded");
   } catch (error) {
      changeState("error");
   }
});
```