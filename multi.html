<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="ローディング表示のシミュレーションができるウェブアプリケーションです。" />
  <meta property="og:title" content="ローディングシミュレーター(複数)" />
  <meta property="og:type" content="website"/>
  <meta property="og:url" content="https://d-sharp.com" />
  <meta property="og:image" content="https://loading.rsasage.com/ogp.png" />
  <meta property="og:site_name" content="ローディングシミュレーター(複数)" />
  <meta property="og:description" content="ローディング表示のシミュレーションができるウェブアプリケーションです。" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:description" content="ローディング表示のシミュレーションができるウェブアプリケーションです。" />
  <meta name="twitter:title" content="ローディングシミュレーター(複数)" />
  <meta name="twitter:site" content="@Arahabica1" />
  <meta name="twitter:image" content="https://loading.rsasage.com/ogp.png" />
  <meta name="twitter:creator" content="@Arahabica1" />
  <link rel="stylesheet" href="./index.css" />
  <title>ローディングシミュレーター(複数)</title>
  <style>
    main {
      display: flex;
      gap: 12px;
      justify-content: center;
      align-items: flex-start;
      padding: 8px 24px;
      flex-wrap: wrap;
      width: 600px;
      height: 600px;
    }
    section {
      width: 100%;
    }
    .container {
      padding: 20px;
      width: 140px;
      height: 140px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    .process-time {
      font-size: 14px;
    }
    main button.next {
      min-width: 140px;
      width: 140px;
    }
    h1 {
      text-align: center;
    }
    @media screen and (max-width: 700px) {
      main {
        gap: 4px;
        width: 100%;
        max-width: 420px;
        height: 320px;
        padding: 0;
      }
      .container {
        padding: 8px;
        width: 100px;
        height: 100px;
      }
      main button.next {
        min-width: 96px;
        width: 96px;
        padding: 4px 8px;
      }
    }
    @media screen and (max-width: 700px) {
      .links {
        max-width: 336px;
        margin-top: 60px;
      }
    }
  </style>
</head>
<body>
  <h1>Loading Simulation<br/>(Multiple)</h1>
  <main>
    <div class="container" data-process="100">
      <section class="landing">
        <div class="process-time">100ms</div>
        <button class="next">次へ</button>
      </section>
      <svg class="loading hidden" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
        <circle fill="none" stroke-width="4" cx="20" cy="20" r="18"></circle>
      </svg>
      <section class="content hidden">
        <div class="main">Hello</div>
        <div>loaded: <span class="loading-time"></span> ms</div>
      </section>
    </div>
    <div class="container" data-process="200">
      <section class="landing">
        <div class="process-time">200ms</div>
        <button class="next">次へ</button>
      </section>
      <svg class="loading hidden" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
        <circle fill="none" stroke-width="4" cx="20" cy="20" r="18"></circle>
      </svg>
      <section class="content hidden">
        <div class="main">Hello</div>
        <div>loaded: <span class="loading-time"></span> ms</div>
      </section>
    </div>
    <div class="container" data-process="300">
      <section class="landing">
        <div class="process-time">300ms</div>
        <button class="next">次へ</button>
      </section>
      <svg class="loading hidden" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
        <circle fill="none" stroke-width="4" cx="20" cy="20" r="18"></circle>
      </svg>
      <section class="content hidden">
        <div class="main">Hello</div>
        <div>loaded: <span class="loading-time"></span> ms</div>
      </section>
    </div>
    <div class="container" data-process="400">
      <section class="landing">
        <div class="process-time">400ms</div>
        <button class="next">次へ</button>
      </section>
      <svg class="loading hidden" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
        <circle fill="none" stroke-width="4" cx="20" cy="20" r="18"></circle>
      </svg>
      <section class="content hidden">
        <div class="main">Hello</div>
        <div>loaded: <span class="loading-time"></span> ms</div>
      </section>
    </div>
    <div class="container" data-process="700">
      <section class="landing">
        <div class="process-time">700ms</div>
        <button class="next">次へ</button>
      </section>
      <svg class="loading hidden" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
        <circle fill="none" stroke-width="4" cx="20" cy="20" r="18"></circle>
      </svg>
      <section class="content hidden">
        <div class="main">Hello</div>
        <div>loaded: <span class="loading-time"></span> ms</div>
      </section>
    </div>
    <div class="container" data-process="950">
      <section class="landing">
        <div class="process-time">950ms</div>
        <button class="next">次へ</button>
      </section>
      <svg class="loading hidden" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
        <circle fill="none" stroke-width="4" cx="20" cy="20" r="18"></circle>
      </svg>
      <section class="content hidden">
        <div class="main">Hello</div>
        <div>loaded: <span class="loading-time"></span> ms</div>
      </section>
    </div>
    <div class="container" data-process="1000">
      <section class="landing">
        <div class="process-time">1000ms</div>
        <button class="next">次へ</button>
      </section>
      <svg class="loading hidden" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
        <circle fill="none" stroke-width="4" cx="20" cy="20" r="18"></circle>
      </svg>
      <section class="content hidden">
        <div class="main">Hello</div>
        <div>loaded: <span class="loading-time"></span> ms</div>
      </section>
    </div>
    <div class="container" data-process="1200">
      <section class="landing">
        <div class="process-time">1200ms</div>
        <button class="next">次へ</button>
      </section>
      <svg class="loading hidden" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
        <circle fill="none" stroke-width="4" cx="20" cy="20" r="18"></circle>
      </svg>
      <section class="content hidden">
        <div class="main">Hello</div>
        <div>loaded: <span class="loading-time"></span> ms</div>
      </section>
    </div>
    <div class="container" data-process="1400">
      <section class="landing">
        <div class="process-time">1400ms</div>
        <button class="next">次へ</button>
      </section>
      <svg class="loading hidden" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
        <circle fill="none" stroke-width="4" cx="20" cy="20" r="18"></circle>
      </svg>
      <section class="content hidden">
        <div class="main">Hello</div>
        <div>loaded: <span class="loading-time"></span> ms</div>
      </section>
    </div>
  </main>
  <div class="links">
    <h2>Demos</h2>
    <ul>
      <li><a href="./">Loading Simulation</a></li>
      <li><a href="./random.html">Loading Simulation (Random)</a></li>
      <li>Loading Simulation (Multi)</li>
    </ul>
  </div>
</body>
<script>
  const waitLoadingAnimation = async (callback, opts) => {
    const delay = opts?.delay ?? 350; // ドーハティ閾値(400ms) - バッファ(50ms)
    const minDuration = opts?.minDuration ?? 600; // 最低表示時間
    // Delayを超えた場合に強制される合計の最低待ち時間
    const requiredWaitTime = delay + minDuration; // 950ms

    const startTime = Date.now();

    // 1. コールバック関数を即座に実行
    const callbackPromise = callback();

    try {
      // 2. 処理の完了を待機
      const result = await callbackPromise;
      const finishedTime = Date.now();
      const actualTime = finishedTime - startTime;

      // 3. Min Durationの適用判定
      if (actualTime < delay) {
        // delay以内に完了した場合は即座に結果を返す (ノイズレス)
        return result;
      }
      // 処理時間がDelayを超えた場合、ローディングが表示されたとみなし、
      // Min Durationのルールを適用する。
      const remainingTime = Math.max(requiredWaitTime - actualTime, 0);

      // 4. 不足している時間分だけ人工的に待機
      if (remainingTime > 0) {
        console.log("Waiting for min duration:", remainingTime);
        // Promiseが解決したにも関わらず、ローディング表示を維持する
        await new Promise((resolve) => {
          setTimeout(resolve, remainingTime);
        });
      }
      return result;
    } catch (error) {
      // エラー時も同様にMin Durationのルールを適用し、チラつきを防ぐ
      const errorTime = Date.now();
      const actualErrorTime = errorTime - startTime;

      if (actualErrorTime > delay) {
        const remainingTime = Math.max(requiredWaitTime - actualErrorTime, 0);
        if (remainingTime > 0) {
          console.log("Waiting for min duration:", remainingTime);
          await new Promise((resolve) => {
            setTimeout(resolve, remainingTime);
          });
        }
      }
      // 待機完了後にエラーをスロー
      throw error;
    }
  };

  let delay = 350;
  let minDuration = 600;
  let flickerAgainst = true;

  const containers = document.querySelectorAll(".container");
  const nextButtons = document.querySelectorAll(".next");

  async function doSomething(progressTime) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, progressTime);
    });
  }

  const start = async () => {
    containers.forEach(async container => {
      const progressTime = parseInt(container.dataset.process, 10);
      const landing = container.querySelector(".landing");
      const loading = container.querySelector(".loading");
      const content = container.querySelector(".content");

      function setHidden(element, hidden) {
        if (hidden) {
            element.classList.add("hidden");
        } else {
            element.classList.remove("hidden");
        }
      }
      function setState(state) {
        setHidden(landing, state !== "none");
        setHidden(loading, state !== "loading");
        setHidden(content, state !== "loaded");
      }
      setState("loading");
      try {
        await waitLoadingAnimation(() => doSomething(progressTime), { delay, minDuration });
        content.querySelector(".loading-time").textContent = progressTime.toFixed(0);
        setState("loaded");
      } catch (error) {
        console.error(error);
        setState("error");
      }
    });
  };
  nextButtons.forEach(button => {
    button.addEventListener("click", start);
  });
</script>
</html>
