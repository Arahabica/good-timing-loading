<html>

<head>
   <link rel="stylesheet" href="./index.css" />
</head>

<body>
   <button class="next">次へ</button>
   <svg class="loading hidden" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
      <circle fill="none" stroke-width="4" cx="20" cy="20" r="18"></circle>
   </svg>
   <div class="content hidden">
      <div class="main">Hello</div>
      <div>loaded: <span class="loading-time"></span> ms</div>
      <button class="reset">リセット</button>
   </div>
   <div class="error-content hidden">
      <div class="error-message">Something went wrong!</div>
      <div>loaded: <span class="loading-time"></span> ms</div>
      <button class="reset">リセット</button>
   </div>
</body>
<script>
const waitLoadingAnimation = async(callback, opts) => {
  const delay = opts?.delay ?? 350; // ドーハティ閾値(400ms) - バッファ(50ms)
  const minDuration = opts?.minDuration ?? 600; // 最小表示時間
  // Delayを超えた場合に強制される合計の最小待ち時間
  const requiredWaitTime = delay + minDuration; // 950ms

  const startTime = Date.now();

  // 1. コールバック関数を即座に実行
  const callbackPromise = callback();

  try {
   // 2. 処理の完了を待機
   const result = await callbackPromise;
   const finishedTime = Date.now();
   const actualTime = finishedTime - startTime;

   // 3. Min Durationの適用判定
   if (actualTime < delay) {
     // delay以内に完了した場合は即座に結果を返す (ノイズレス)
     return result;
   }
   // 処理時間がDelayを超えた場合、ローディングが表示されたとみなし、
   // Min Durationのルールを適用する。
   const remainingTime = Math.max(requiredWaitTime - actualTime, 0);

   // 4. 不足している時間分だけ人工的に待機
   if (remainingTime > 0) {
     console.log("Waiting for min duration:", remainingTime);
     // Promiseが解決したにも関わらず、ローディング表示を維持する
     await new Promise((resolve) => {
        setTimeout(resolve, remainingTime);
     });
   }
    return result;
  } catch (error) {
    // エラー時も同様にMin Durationのルールを適用し、チラつきを防ぐ
    const errorTime = Date.now();
    const actualErrorTime = errorTime - startTime;

    if (actualErrorTime > delay) {
      const remainingTime = Math.max(requiredWaitTime - actualErrorTime, 0);
      if (remainingTime > 0) {
        console.log("Waiting for min duration:", remainingTime);
        await new Promise((resolve) => {
          setTimeout(resolve, remainingTime);
        });
      }
    }
    // 待機完了後にエラーをスロー
    throw error;
  }
};

const nextButton = document.querySelector(".next");
const loading = document.querySelector(".loading");
const content = document.querySelector(".content");
const errorContent = document.querySelector(".error-content");
const resetButton = document.querySelectorAll(".reset");

function setHidden(element, hidden) {
   if (hidden) {
      element.classList.add("hidden");
   } else {
      element.classList.remove("hidden");
   }
}
function changeState(mode) {
   setHidden(nextButton, mode !== "none");
   setHidden(loading, mode !== "loading");
   setHidden(content, mode !== "loaded");
   setHidden(errorContent, mode !== "error");
}
async function doSomething(duration) {
   return new Promise((resolve, reject) => {
      setTimeout(() => {
         if (Math.random() < 0.2) {
            // 20%の確率でエラーをスロー
            reject(new Error("Something went wrong!"));
         }
         resolve(duration);
      }, duration);
   });
}

nextButton.addEventListener("click", async () => {
   changeState("loading");
   // 0〜1200msの間でランダムに待機
   const duration = Math.floor(24 * Math.random()) * 50;
   try {
     await waitLoadingAnimation(() => doSomething(duration));
     content.querySelector(".loading-time").textContent = duration.toFixed(0);
     changeState("loaded");
   } catch (error) {
      errorContent.querySelector(".loading-time").textContent = duration.toFixed(0);
      changeState("error");
      return;
   }
});
resetButton.forEach(button => {
   button.addEventListener("click", () => {
      changeState("none");
   });
});
</script>
</html>