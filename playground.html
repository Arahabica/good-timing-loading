<html>

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="./playground.css?x=7" />
  <title>Playground | Good Timing Loading</title>
</head>

<body>
  <section class="landing">
    <fieldset>
      <div class="title">処理時間</div>
      <div class="value">
        <span id="progressTimeValue">500</span>
        <span>ms</span>
      </div>
      <div class="controls">
        <button id="progressTimeDown">
          <svg viewBox="0 0 40 40">
            <path d="M0 8 L20 32 L40 8" stroke="currentColor" fill="none" stroke-width="3" />
          </svg>
        </button>
        <button id="progressTimeUp">
          <svg viewBox="0 0 40 40">
            <path d="M0 32 L20 8 L40 32" stroke="currentColor" fill="none" stroke-width="3" />
          </svg>
        </button>
      </div>
    </fieldset>
    <fieldset>
      <div class="title">delay</div>
      <div class="value">
        <span id="delayValue">350</span>
        <span>ms</span>
      </div>
      <div class="controls">
        <button id="delayDown">
          <svg viewBox="0 0 40 40">
            <path d="M0 8 L20 32 L40 8" stroke="currentColor" fill="none" stroke-width="3" />
          </svg>
        </button>
        <button id="delayUp">
          <svg viewBox="0 0 40 40">
            <path d="M0 32 L20 8 L40 32" stroke="currentColor" fill="none" stroke-width="3" />
          </svg>
        </button>
      </div>
    </fieldset>
    <fieldset>
      <div class="title">minDuration</div>
      <div class="value">
        <span id="minDurationValue">600</span>
        <span>ms</span>
      </div>
      <div class="controls">
        <button id="minDurationDown">
          <svg viewBox="0 0 40 40">
            <path d="M0 8 L20 32 L40 8" stroke="currentColor" fill="none" stroke-width="3" />
          </svg>
        </button>
        <button id="minDurationUp">
          <svg viewBox="0 0 40 40">
            <path d="M0 32 L21 7 L40 32" stroke="currentColor" fill="none" stroke-width="3" />
          </svg>
        </button>
      </div>
    </fieldset>
    <fieldset>
      <div class="title">ちらつき対策</div>
      <div class="value">
        <span id="flickerAgainstValue">ON</span>
      </div>
      <div class="controls">
        <button id="flickerAgainst" class="check">
          <svg viewBox="0 0 40 40">
            <path d="M0 9 L12 30 L40 4" stroke="currentColor" fill="none" stroke-width="3" />
          </svg>
        </button>
      </div>
    </fieldset>
    <button class="next" style="margin-top: 36px;">次へ</button>
    <div style="margin-top: 60px;">
      <a href="./index.html">Simple</a>
    </div>
  </section>
  <svg class="loading hidden" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
    <circle fill="none" stroke-width="4" cx="20" cy="20" r="18"></circle>
  </svg>
  <svg class="normal-loading hidden" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
    <circle fill="none" stroke-width="4" cx="20" cy="20" r="18"></circle>
  </svg>
  <section class="content hidden">
    <div class="main">Hello</div>
    <div>loaded: <span class="loading-time"></span> ms</div>
    <button class="reset">リセット</button>
  </section>
  <section class="error-content hidden">
    <div class="error-message">Something went wrong!</div>
    <div>loaded: <span class="loading-time"></span> ms</div>
    <button class="reset">リセット</button>
  </section>
</body>
<script>
  const waitLoadingAnimation = async (callback, opts) => {
    const delay = opts?.delay ?? 350; // ドーハティ閾値(400ms) - バッファ(50ms)
    const minDuration = opts?.minDuration ?? 600; // 最小表示時間
    // Delayを超えた場合に強制される合計の最小待ち時間
    const requiredWaitTime = delay + minDuration; // 950ms

    const startTime = Date.now();

    // 1. コールバック関数を即座に実行
    const callbackPromise = callback();

    try {
      // 2. 処理の完了を待機
      const result = await callbackPromise;
      const finishedTime = Date.now();
      const actualTime = finishedTime - startTime;

      // 3. Min Durationの適用判定
      if (actualTime < delay) {
        // delay以内に完了した場合は即座に結果を返す (ノイズレス)
        return result;
      }
      // 処理時間がDelayを超えた場合、ローディングが表示されたとみなし、
      // Min Durationのルールを適用する。
      const remainingTime = Math.max(requiredWaitTime - actualTime, 0);

      // 4. 不足している時間分だけ人工的に待機
      if (remainingTime > 0) {
        console.log("Waiting for min duration:", remainingTime);
        // Promiseが解決したにも関わらず、ローディング表示を維持する
        await new Promise((resolve) => {
          setTimeout(resolve, remainingTime);
        });
      }
      return result;
    } catch (error) {
      // エラー時も同様にMin Durationのルールを適用し、チラつきを防ぐ
      const errorTime = Date.now();
      const actualErrorTime = errorTime - startTime;

      if (actualErrorTime > delay) {
        const remainingTime = Math.max(requiredWaitTime - actualErrorTime, 0);
        if (remainingTime > 0) {
          console.log("Waiting for min duration:", remainingTime);
          await new Promise((resolve) => {
            setTimeout(resolve, remainingTime);
          });
        }
      }
      // 待機完了後にエラーをスロー
      throw error;
    }
  };

  let progressTime = 500;
  let delay = 350;
  let minDuration = 600;
  let flickerAgainst = true;

  const landing = document.querySelector(".landing");
  const loading = document.querySelector(".loading");
  const content = document.querySelector(".content");
  const errorContent = document.querySelector(".error-content");
  const nextButton = document.querySelector(".next");
  const resetButton = document.querySelectorAll(".reset");

  function setHidden(element, hidden) {
    if (hidden) {
      element.classList.add("hidden");
    } else {
      element.classList.remove("hidden");
    }
  }
  function setState(state) {
    setHidden(landing, state !== "none");
    setHidden(loading, state !== "loading");
    setHidden(content, state !== "loaded");
    setHidden(errorContent, state !== "error");
  }
  async function doSomething() {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (Math.random() < 0.02) {
          // 2%の確率でエラーをスロー
          reject(new Error("Something went wrong!"));
        }
        resolve();
      }, progressTime);
    });
  }

  nextButton.addEventListener("click", async () => {
    setState("loading");
    try {
      await waitLoadingAnimation(() => doSomething(), { delay, minDuration });
      content.querySelector(".loading-time").textContent = progressTime.toFixed(0);
      setState("loaded");
    } catch (error) {
      setState("error");
    }
  });
  resetButton.forEach(button => {
    button.addEventListener("click", () => {
      setState("none");
    });
  });

  function setupNumberControl(config) {
    const {
      upButton,
      downButton,
      valueElement,
      getValue,
      setValue,
      min,
      max,
      step } = config;
    let intervalId = null;
    let timeoutId = null;

    function updateButtons() {
      upButton.disabled = getValue() >= max;
      downButton.disabled = getValue() <= min;
    }

    function increment() {
      const current = getValue();
      if (current < max) {
        setValue(Math.min(current + step, max));
        valueElement.textContent = getValue();
        updateButtons();
      }
    }

    function decrement() {
      const current = getValue();
      if (current > min) {
        setValue(Math.max(current - step, min));
        valueElement.textContent = getValue();
        updateButtons();
      }
    }

    function stopInterval() {
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      }
    }

    upButton.addEventListener("click", increment);
    upButton.addEventListener("mousedown", () => {
      timeoutId = setTimeout(() => {
        intervalId = setInterval(increment, 50);
      }, 380);
    });
    upButton.addEventListener("mouseup", stopInterval);
    upButton.addEventListener("mouseleave", stopInterval);

    downButton.addEventListener("click", decrement);
    downButton.addEventListener("mousedown", () => {
      timeoutId = setTimeout(() => {
        intervalId = setInterval(decrement, 50);
      }, 380);
    });
    downButton.addEventListener("mouseup", stopInterval);
    downButton.addEventListener("mouseleave", stopInterval);

    updateButtons();
  }

  // progressTime controls
  setupNumberControl({
    upButton: document.getElementById("progressTimeUp"),
    downButton: document.getElementById("progressTimeDown"),
    valueElement: document.getElementById("progressTimeValue"),
    getValue: () => progressTime,
    setValue: (v) => { progressTime = v; },
    min: 0,
    max: 5000,
    step: 50
  });

  // delay controls
  setupNumberControl({
    upButton: document.getElementById("delayUp"),
    downButton: document.getElementById("delayDown"),
    valueElement: document.getElementById("delayValue"),
    getValue: () => delay,
    setValue: (v) => {
      delay = v;
      loading.style.animation = `rotator 1.6s linear ${delay}ms infinite`;
      const circle = loading.querySelector("circle");
      circle.style.animation = `
        spin-hidden ${delay}ms ease-in-out,
        spin-fade-in 0.05s ease-in-out ${delay}ms forwards,
        spin-dash 1.6s ease-in-out ${delay}ms infinite
      `;
    },
    min: 0,
    max: 5000,
    step: 50
  });

  // minDuration controls
  setupNumberControl({
    upButton: document.getElementById("minDurationUp"),
    downButton: document.getElementById("minDurationDown"),
    valueElement: document.getElementById("minDurationValue"),
    getValue: () => minDuration,
    setValue: (v) => { minDuration = v; },
    min: 0,
    max: 5000,
    step: 50
  });

  const flickerAgainstButton = document.getElementById("flickerAgainst");
  const flickerAgainstValue = document.getElementById("flickerAgainstValue");
  flickerAgainstButton.addEventListener("click", () => {
    flickerAgainst = !flickerAgainst;
    flickerAgainstValue.textContent = flickerAgainst ? "ON" : "OFF";
    flickerAgainstButton.classList.toggle("off", !flickerAgainst);
  });
</script>

</html>
